## PART 1: NAVIGATION –
1.	To start solving this program, I first looked for the reason for infinite looping of the code. I used Spyder-Anaconda3 IDE to debug the code and realised that the previously traversed moves were added again to the fringe, including the moves that were leading to dead-end or the moves the agent previously travelled from. To fix this, I introduced a variable named ‘visited’ which creates a 2D list of the size of the map and initialised all the position to False, indicating the states that are not traversed yet. Once we get a list of moves from the ‘moves’ function, we return from the ‘search1’ function if it is the goal state, else we verify if the move is available in ‘visited’ list, and then we push it to the fringe in case it is not traversed yet and add it to the visited list (line number 44-47) in the code. Implementing the visited list solved the infinite loop issue.
2.	The next challenge was to find the correct map directions to the goal states. I tried the following approach to map the map directions. 
- Initially, I tried to map the direction of the next move based on the previous move. For example, if the current position is (a1,b1) and the previous position was (a2, b2), if a1 < a2, then the agent has travelled 1 row up than the previous state and I pushed a ‘N’ indicating north into a new list named ‘directions’. After implementing this I realised the shortcomings of BFS. Since BFS searches each node till the goal is found, the nodes that were not leading to the goal, or resulted a dead-end were also added to the directions list and the final direction string was longer than the displayed length. 
- To fix the incorrect directions, I tried multiple approaches, one including trying to implement an A* algorithm as taught in module 4 lectures. I created a function that would find the Euclidean distance of all the next states from the goal and push them into the fringe by prioritizing the move that is in shortest distance to the goal. However, I had no idea how to prioritize when two moves had the same distance. The solution did find the correct path, while removing most of the incorrect directions from the previous solution, but it still had directions in the final solution that were at a same distance from the goal.
- After reading multiple article and couple of YouTube videos (https://www.youtube.com/watch?v=KiCBXu4P-2Y&t=6s – This one being the most helpful, at min 8:55), I got the idea of storing the moves itself and reconstruct the shortest path from it. Hence, I introduced another list named ‘track’ to keep track of the all the nodes that are travelled in the map. The nodes are stored in the following format [(source_row, source_column), (destination_row, destination_column)]. Once the goal if found, I call the ‘shortest_path’ function to find the shortest path that is available from the goal to the starting position (yes, in the opposite direction). The idea here is that to connect the route backwards using the source of the current node list to a node from the track list which was a destination to a previously traversed node in the track list and the child of the nodes which are not expanded would not be available in the track.

3.	Issue faced – Using the ‘curr_dist + 1’ to track the current distance does not always gives the shortest path. For example, placing the goal at location (1,4) in the provided map will give us the curr_dist + 1 = 18, even though the shortest path is only 16 moves away. The reason for this is how the stack and moves are implemented. After finding the moves from location (2,5) (where current distance would be 14), it pushes [(1,5), 15] and [(2,6), 15] into the fringe. The (2,6) node is popped out first, and then the path [(2,6), 15] -> [(1,6), 16] -> [(1,5), 17] -> [(1,4), 18] and the search stops there and a possible shortest path of [(1,5), 15] -> [(1,4), 16] is missed out. I was able to fix it using the ‘shortest_path’ function and then finding the length of the reverse tracked path as the shortest distance.

4.	After the search is completed, if no solution is found, I added a ‘return "Inf", "" ‘at line number 48 indicating no solution is found.

## PART 2: HIDE-AND-SEEK –
1.	Just like the previous program, I tried to debug the provided code first to understand how the implemented functionality work. The ‘successors’ function finds the locations on the map with ‘.’ Value and then passes the combination of row and column along with the board to add_pichu to insert the pichu to an available location. I understood I could add another function to find the valid locations, that is locations that do not have a p placed in their respective row and column, and call the newly implement ‘is_valid’ function along the condition where empty locations are found.
2.	Now to check the valid rows and columns, I went back to the N-queen problem discussed in the lecture videos and read a couple of its implementation online. However, in every N-queen implantation I came across, the board always had a squared dimension and there were no walls between them, and they mostly followed the idea of placing the queen from left to right manner. After trying to implement row and column search in the way N-queen problems are solved (https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/- this post helped), I realised I cannot deal with the scenario of placing two p in the same row and direction having a wall between them. After some experimentation, I was able to place the pichus correctly by verifying all the position up and down the column and forwards and backwards in the row, which I was able to do using four different for loops. In cases where we find a pichu already available along the row or column, I set the row_valid and col_valid values to false, and if either of them is false, the pichu is not placed in that location. And in case a wall X or @ is found, we simple break from the loop. 
3.	Now since the code was working as expected, the next challenge was to stop the infinite loop. The program kept on search when the K value was greater than the maximum number of pichus can be placed in the map (9 in case of the provided map). To fix this, I understood that I need to not search the states that have already been searched. This would significantly reduce the search time. To remember the states, I added a new list named ‘visited’ to store the visited states. If the next item in the fringe is already searched, we can safely skip it. This solved the issue of code running interminable for K values greater than the max possible values.
4.	Search Abstraction – 
a.	The state space – All available dots on the map that can be occupied by the next available ‘p’. 
-	A ‘p’ can be placed on the position on the board if there are no other ‘p’ placed on the same row or column. 
-	Walls denoted by X or @ can be occur in between placed ‘p’ on the map.
b.	Initial state – 2D map with only 1 ‘p’ placed.
c.	Goal state – Placing K number of ‘p’ in non-conflicting positions on the map.
d.	Successor function – A set of state of the map with (n+1) non-conflicting placed ‘p’ on a n number of ‘p’ placed state of the map.
e.	Cost function – The cost of finding all the states that can place (n+1) ‘p’ in non-conflicting positions.

# Bonus Task – 
To find the maximum number of pichus that can be placed on the board, I introduced another ‘max_pichus’ that hold the board configuration having the greatest number of placed pichus in the board. If other states if found with more pichus, the max_pichu is updated to the new board. When K = 0, we also needed to check along the diagonals and I decided to add it in the same ‘is_valid’ function.
Search Abstraction for bonus – 
a.	The state space – All available dots on the map that can be occupied by the next available ‘p’. 
-	A ‘p’ can be placed on the position on the board if there are no other ‘p’ placed on the same row or column or along the diagonals. 
-	Walls denoted by X or @ can be occur in between placed ‘p’ on the map.
b.	Initial state – 2D map with only 1 ‘p’ placed.
c.	Goal state – Finding maximum number of ‘p’ that can be placed if K = 0.
d.	Successor function – A set of state of the map with (n+1) non-conflicting placed ‘p’ on a n number of ‘p’ placed state of the map.
e.	Cost function – The cost of finding all the states that can place (n+1) ‘p’ in non-conflicting positions.

